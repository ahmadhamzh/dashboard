// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PolicyTemplateSpec policy template spec
//
// swagger:model PolicyTemplateSpec
type PolicyTemplateSpec struct {

	// Admission controls if rules are applied during admission.
	// Optional. Default value is "true".
	// +optional
	// +kubebuilder:default=true
	Admission bool `json:"admission,omitempty"`

	// Background controls if rules are applied to existing resources during a background scan.
	// Optional. Default value is "true". The value must be set to "false" if the policy rule
	// uses variables that are only available in the admission review request (e.g. user name).
	// +optional
	// +kubebuilder:default=true
	Background bool `json:"background,omitempty"`

	// Category is the category of the policy, specified as an annotation in the Kyverno policy
	//
	// +optional
	Category string `json:"category,omitempty"`

	// Default determines whether we apply the policy (create policy binding)
	//
	// +optional
	Default bool `json:"default,omitempty"`

	// Description is the description of the policy, specified as an annotation in the Kyverno policy
	Description string `json:"description,omitempty"`

	// EmitWarning enables API response warnings for mutate policy rules or validate policy rules with validationFailureAction set to Audit.
	// Enabling this option will extend admission request processing times. The default value is "false".
	// +optional
	// +kubebuilder:default=false
	EmitWarning bool `json:"emitWarning,omitempty"`

	// Enforced indicates whether this policy is mandatory
	//
	// If true, this policy is mandatory
	// A PolicyBinding referencing it cannot disable it
	Enforced bool `json:"enforced,omitempty"`

	// Deprecated, use generateExisting under the generate rule instead
	// +optional
	GenerateExisting bool `json:"generateExisting,omitempty"`

	// Deprecated, use generateExisting instead
	// +optional
	GenerateExistingOnPolicyUpdate bool `json:"generateExistingOnPolicyUpdate,omitempty"`

	// Deprecated, use mutateExistingOnPolicyUpdate under the mutate rule instead
	// +optional
	MutateExistingOnPolicyUpdate bool `json:"mutateExistingOnPolicyUpdate,omitempty"`

	// ProjectID is the ID of the project for which the policy template is created
	//
	// Relevant only for project visibility policies
	// +optional
	ProjectID string `json:"projectID,omitempty"`

	// Rules is a list of Rule instances. A Policy contains multiple rules and
	// each rule can validate, mutate, or generate resources.
	Rules []*Rule `json:"rules"`

	// Deprecated.
	SchemaValidation bool `json:"schemaValidation,omitempty"`

	// Severity indicates the severity level of the policy
	//
	// +optional
	Severity string `json:"severity,omitempty"`

	// Title is the title of the policy, specified as an annotation in the Kyverno policy
	Title string `json:"title,omitempty"`

	// UseServerSideApply controls whether to use server-side apply for generate rules
	// If is set to "true" create & update for generate rules will use apply instead of create/update.
	// Defaults to "false" if not specified.
	// +optional
	UseServerSideApply bool `json:"useServerSideApply,omitempty"`

	// Deprecated, use validationFailureActionOverrides under the validate rule instead.
	ValidationFailureActionOverrides []*ValidationFailureActionOverride `json:"validationFailureActionOverrides"`

	// Visibility specifies where the policy is visible.
	//
	// Can be one of: global, project, or cluster
	// +kubebuilder:validation:Enum=global;project;cluster
	Visibility string `json:"visibility,omitempty"`

	// Deprecated, use webhookTimeoutSeconds under webhookConfiguration instead.
	WebhookTimeoutSeconds int32 `json:"webhookTimeoutSeconds,omitempty"`

	// apply rules
	ApplyRules ApplyRulesType `json:"applyRules,omitempty"`

	// failure policy
	FailurePolicy FailurePolicyType `json:"failurePolicy,omitempty"`

	// validation failure action
	ValidationFailureAction ValidationFailureAction `json:"validationFailureAction,omitempty"`

	// webhook configuration
	WebhookConfiguration *WebhookConfiguration `json:"webhookConfiguration,omitempty"`
}

// Validate validates this policy template spec
func (m *PolicyTemplateSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationFailureActionOverrides(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApplyRules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailurePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationFailureAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWebhookConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyTemplateSpec) validateRules(formats strfmt.Registry) error {
	if swag.IsZero(m.Rules) { // not required
		return nil
	}

	for i := 0; i < len(m.Rules); i++ {
		if swag.IsZero(m.Rules[i]) { // not required
			continue
		}

		if m.Rules[i] != nil {
			if err := m.Rules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyTemplateSpec) validateValidationFailureActionOverrides(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationFailureActionOverrides) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationFailureActionOverrides); i++ {
		if swag.IsZero(m.ValidationFailureActionOverrides[i]) { // not required
			continue
		}

		if m.ValidationFailureActionOverrides[i] != nil {
			if err := m.ValidationFailureActionOverrides[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationFailureActionOverrides" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationFailureActionOverrides" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyTemplateSpec) validateApplyRules(formats strfmt.Registry) error {
	if swag.IsZero(m.ApplyRules) { // not required
		return nil
	}

	if err := m.ApplyRules.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("applyRules")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("applyRules")
		}
		return err
	}

	return nil
}

func (m *PolicyTemplateSpec) validateFailurePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.FailurePolicy) { // not required
		return nil
	}

	if err := m.FailurePolicy.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("failurePolicy")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("failurePolicy")
		}
		return err
	}

	return nil
}

func (m *PolicyTemplateSpec) validateValidationFailureAction(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationFailureAction) { // not required
		return nil
	}

	if err := m.ValidationFailureAction.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("validationFailureAction")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("validationFailureAction")
		}
		return err
	}

	return nil
}

func (m *PolicyTemplateSpec) validateWebhookConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.WebhookConfiguration) { // not required
		return nil
	}

	if m.WebhookConfiguration != nil {
		if err := m.WebhookConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("webhookConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("webhookConfiguration")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy template spec based on the context it is used
func (m *PolicyTemplateSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidationFailureActionOverrides(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateApplyRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailurePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidationFailureAction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWebhookConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyTemplateSpec) contextValidateRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Rules); i++ {

		if m.Rules[i] != nil {
			if err := m.Rules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyTemplateSpec) contextValidateValidationFailureActionOverrides(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ValidationFailureActionOverrides); i++ {

		if m.ValidationFailureActionOverrides[i] != nil {
			if err := m.ValidationFailureActionOverrides[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationFailureActionOverrides" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationFailureActionOverrides" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyTemplateSpec) contextValidateApplyRules(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ApplyRules.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("applyRules")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("applyRules")
		}
		return err
	}

	return nil
}

func (m *PolicyTemplateSpec) contextValidateFailurePolicy(ctx context.Context, formats strfmt.Registry) error {

	if err := m.FailurePolicy.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("failurePolicy")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("failurePolicy")
		}
		return err
	}

	return nil
}

func (m *PolicyTemplateSpec) contextValidateValidationFailureAction(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ValidationFailureAction.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("validationFailureAction")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("validationFailureAction")
		}
		return err
	}

	return nil
}

func (m *PolicyTemplateSpec) contextValidateWebhookConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.WebhookConfiguration != nil {
		if err := m.WebhookConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("webhookConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("webhookConfiguration")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyTemplateSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyTemplateSpec) UnmarshalBinary(b []byte) error {
	var res PolicyTemplateSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
